<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css"
 href="https://fonts.googleapis.com/css?family=PT+Mono"
>
<style type="text/css">
body {
  font-family: 'PT Mono', monospace;
}

</style>
<script>
Solver = {};

var _ = 0;
Solver.puzzle = [
  [ _, _, _, _, _, _, _, 1, _ ],
  [ _, _, _, 3, 4, _, 5, 4, _ ],
  [ _, _, _, _, 6, _, _, _, _ ],
  [ _, _, _, 7, 8, _, _, _, _ ],
  [ _, 3, _, _, _, 1, 8, 2, _ ],
  [ _, 9, _, _, _, _, _, 5, _ ],
  [ _, _, 6, _, _, _, _, _, _ ],
  [ _, _, _, _, _, 9, 7, _, _ ],
  [ _, _, _, _, _, _, _, _, 2 ]
];
Solver.puzzle = [
  [ 1, _, _, _, _, _, _, _, _, _ ],
  [ _, _, _, _, _, _, _, _, 5, _ ],
  [ _, 6, _, 1, _, _, _, _, _, _ ],
  [ _, _, _, _, _, 4, 3, _, _, _ ],
  [ _, _, _, _, _, _, 6, _, 5, _ ],
  [ _, 8, _, 3, _, _, _, _, _, _ ],
  [ _, _, _, 4, 7, _, _, _, _, _ ],
  [ _, _, _, _, _, _, 2, _, 8, _ ],
  [ _, 7, _, _, _, _, _, _, _, _ ],
  [ _, _, _, _, _, _, _, _, _, 2 ]
];
Solver.puzzle = [
  [ _, _,10, 1, _, 1, 3, _, _, _ ],
  [ _, _, _, _, _, _, _, _, _, _ ],
  [ _, _, _, _, _, _, _, 5, _, _ ],
  [ _, _, _, 2, _, _, _, _, _, _ ],
  [ _, _, _, _, _, 7, 8, _, _, 3 ],
  [ _, _, _, _, _, _, _, _, _, _ ],
  [10, _, _, _, 9, 7, _, _, 6, _ ],
  [ 4,11, _, _, _, _, _, 9, _, _ ],
  [ _, _, _, _, 8, _, _, _, _, _ ],
  [ 4, 5, 2, _, 6, _,11, _, _, _ ]
];
Solver.puzzle = [
  [ 6, 5, _, _, _, 3, 4, _, _ ],
  [ _, _, _, _, _, _, _, _, _ ],
  [ 1, 7, _, _, _, _, _, _, 4 ],
  [ _, 6, _, _, _, 8, _, _, _ ],
  [ _, _, _, _, _, 2, _, 5, _ ],
  [ _, _, _, _, _, _, _, _, 3 ],
  [ _, _, 7, _, _, _, _, _, _ ],
  [ _, _, _, _, _, 1, _, 8, _ ],
  [ _, _, _, _, _, 2, _, _, _ ]
];
/*
Solver.puzzle = [
  [ _, _, _, 4, _, _, _ ],
  [ _, 3, _, _, 2, 5, _ ],
  [ _, _, _, 3, 1, _, _ ],
  [ _, _, _, 5, _, _, _ ],
  [ _, _, _, _, _, _, _ ],
  [ _, _, 1, _, _, _, _ ],
  [ 2, _, _, _, 4, _, _ ]
];
Solver.puzzle = [
  [ 2, 3, 3, 1 ],
  [ _, _, _, _ ],
  [ _, _, 2, _ ],
  [ 1, _, _, _ ]
];
*/

Solver.message = function (line, replace) {
  line = line || '';
  if (replace) {
    Solver.messageBox.innerHTML = '';
  }
  Solver.messageBox.innerHTML += line + '<br />';
};

window.onload = function () {
  var startTime = Date.now();
  Solver.messageBox = document.getElementById('messageBox');
  var puzzle = Solver.puzzle,
      numRows = puzzle.length,
      numCols = puzzle[0].length,
      pieces = [ [0, 2], [1, 3], [0, 1], [1, 2], [2, 3], [3, 0] ],
      chars = [ '&#x2502', '&#x2500',
                '&#x2514', '&#x250c', '&#x2510', '&#x2518' ],
      numPieces = pieces.length,
      opposite = [ 2, 3, 0, 1 ],
      dr = [ -1, 0, 1, 0 ],
      dc = [ 0, 1, 0, -1 ],
      state = new Array(numRows),
      mark = new Array(numRows),
      colors = [],
      endpoints = {},
      finished = false;
  pieces = pieces.map(function (piece, ix) {
    var a = piece[0], b = piece[1],
        hasDir = {};
    hasDir[a] = hasDir[b] = true;
    return { hasDir: hasDir, dirs: [ a, b ], char: chars[ix] };
  });
  for (var r = 0; r < numRows; ++r) {
    state[r] = new Array(numCols);
    mark[r] = new Array(numCols);
    for (var c = 0; c < numCols; ++c) {
      state[r][c] = null;
      mark[r][c] = false;
      var color = puzzle[r][c];
      if (color === 0) {
        continue;
      }
      if (endpoints[color] === undefined) {
        colors.push(color);
        endpoints[color] = [];
      }
      endpoints[color].push({ r: r, c: c });
    }
  }
  function feasibleSeek(r, c, color, mustFind) {
    var piece = state[r][c],
        dirs = piece.dirs;
    for (var i = dirs.length - 1; i >= 0; --i) {
      var dir = dirs[i],
          R = r + dr[dir],
          C = c + dc[dir];
      if (R == -1 || R == numRows || C == -1 || C == numCols) {
        return false;
      }
      if (mark[R][C]) {
        continue;
      }
      var piece = state[R][C];
      if (!piece) {
        if (puzzle[R][C] != 0) {
          return puzzle[R][C] == color;
        }
        return (mustFind ? false : true); 
      }
      if (!piece.hasDir[opposite[dir]]) {
        return false;
      }
      mark[r][c] = true;
      var result = feasibleSeek(R, C, color);
      mark[r][c] = false;
      return result;
    }
  }
  function feasiblePaths(mustFind) {
    var pathCount = 0;
    for (var i = colors.length - 1; i >= 0; --i) {
      var color = colors[i];
      for (var j = endpoints[color].length - 1; j >= 0; --j) {
        var endpoint = endpoints[color][j],
            r = endpoint.r,
            c = endpoint.c,
            dir,
            count = 0;
        for (var k = 0; k < 4; ++k) {
          var R = r + dr[k],
              C = c + dc[k];
          if (R == -1 || R == numRows || C == -1 || C == numCols) {
            continue;
          }
          var other = state[R][C];
          if (other && other.hasDir[opposite[k]]) {
            dir = k;
            ++count;
          }
        }
        if (count == 0) {
          continue;
        }
        if (count > 1) {
          return false;
        }
        mark[r][c] = true;
        var feasible = feasibleSeek(r + dr[dir], c + dc[dir], color, mustFind);
        mark[r][c] = false;
        if (!feasible) {
          return false;
        }
        ++pathCount;
      }
    }
    //Solver.message('<span style="color:red;">' + pathCount + ' paths</span>');
    return (mustFind ? pathCount == 2 * colors.length : true);
  }
  function connectsToward(r, c, dir) {
    var R = r + dr[dir],
        C = c + dc[dir];
    if (R == -1 || R == numRows || C == -1 || C == numCols) {
      return false;
    }
    var other = state[R][C];
    if (!other) {
      return true;
    }
    return other.hasDir[opposite[dir]];
  }
  function display() {
    for (var i = 0; i < numRows; ++i) {
      var row = state[i].map(function (piece, j) {
        return (piece ? piece.char : puzzle[i][j]);
      });
      Solver.message(row.join(' '));
    }
  }
  function seek(r, c) {
    if (finished) {
      return;
    }
    if (c == numCols) {
      ++r;
      if (r == numRows) {
        console.log('check');
        if (!feasiblePaths(true)) {
          return;
        }
        console.log('solved');
        console.log((Date.now() - startTime) / 1000 + ' s');
        display();
        finished = true;
        return;
      }
      seek(r, 0);
      return;
    }
    if (puzzle[r][c] != 0) {
      seek(r, c + 1);
      return;
    }
    for (var i = 0; i != numPieces; ++i) {
      var piece = pieces[i],
          a = piece.dirs[0],
          b = piece.dirs[1];
      state[r][c] = piece;
      if (!connectsToward(r, c, a) || !connectsToward(r, c, b)) {
        continue;
      }
      for (var j = 0; j != 4; ++j) {
        var R = r + dr[j],
            C = c + dc[j];
        if (R == -1 || R == numRows || C == -1 || C == numCols) {
          continue;
        }
        var other = state[R][C];
        if (other && other.hasDir[opposite[j]] && !piece.hasDir[j]) {
          break;
        }
      }
      if (j != 4) {
        continue;
      }
      // other checks
      if (!feasiblePaths()) {
        continue;
      }
      //display();
      // recursive seek
      //console.log(r, c, '<-', piece);
      seek(r, c + 1);
      if (finished) {
        return;
      }
    }
    state[r][c] = null;
  }
  seek(0, 0);
};
</script>
</head>
<body>

<div id="messageBox">
</div>

</body>
</html>
